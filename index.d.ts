// Generated by dts-bundle-generator v9.5.1

import EventEmitter = require('events');
import { Transform } from 'stream';

export declare class Dispatcher extends EventEmitter<[
	never
]> {
	constructor(opts: any);
	dispatch(): void;
	close(): void;
	destroy(): void;
	compose(...args: any[]): this;
}
declare class DispatcherBase extends Dispatcher {
	constructor();
	get destroyed(): any;
	get closed(): any;
	close(callback: any): Promise<any>;
	destroy(err: any, callback: any): Promise<any>;
	dispatch(opts: any, handler: any): any;
	[kOnDestroyed]: any;
	[kOnClosed]: any[];
}
declare const kOnDestroyed: unique symbol;
declare const kOnClosed: unique symbol;
export declare class Client extends DispatcherBase {
	/**
	 *
	 * @param {string|URL} url
	 * @param {*} options
	 */
	constructor(url: string | URL, { maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, maxConcurrentStreams, allowH2 }?: any);
	set pipelining(value: any);
	get pipelining(): any;
	[kClosedResolve]: any;
}
declare const kClosedResolve: unique symbol;
declare class PoolStats {
	constructor(pool: any);
	get connected(): any;
	get free(): any;
	get pending(): any;
	get queued(): any;
	get running(): any;
	get size(): any;
	[kPool]: any;
}
declare const kPool: unique symbol;
declare class FixedQueue {
	head: FixedCircularBuffer;
	tail: FixedCircularBuffer;
	isEmpty(): boolean;
	push(data: any): void;
	shift(): any;
}
declare class FixedCircularBuffer {
	bottom: number;
	top: number;
	list: any[];
	next: any;
	isEmpty(): boolean;
	isFull(): boolean;
	push(data: any): void;
	shift(): any;
}
declare class PoolBase extends DispatcherBase {
	get stats(): PoolStats;
	[kAddClient](client: any): this;
	[kRemoveClient](client: any): void;
	[kQueue]: FixedQueue;
	[kClients]: any[];
	[kOnDrain]: any;
	[kOnConnect]: (origin: any, targets: any) => void;
	[kOnDisconnect]: (origin: any, targets: any, err: any) => void;
	[kOnConnectionError]: (origin: any, targets: any, err: any) => void;
	[kStats]: PoolStats;
	[kClosedResolve$1]: (value: any) => void;
	[kNeedDrain]: boolean;
}
declare const kClients: unique symbol;
declare const kNeedDrain: unique symbol;
declare const kAddClient: unique symbol;
declare const kRemoveClient: unique symbol;
declare const kGetDispatcher: unique symbol;
declare const kQueue: unique symbol;
declare const kOnDrain: unique symbol;
declare const kOnConnect: unique symbol;
declare const kOnDisconnect: unique symbol;
declare const kOnConnectionError: unique symbol;
declare const kStats: unique symbol;
declare const kClosedResolve$1: unique symbol;
export declare class Pool extends PoolBase {
	constructor(origin: any, { connections, factory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options }?: {
		factory?: typeof defaultFactory;
	});
	[kGetDispatcher](): any;
	[kConnections]: any;
	[kOptions]: any;
	[kFactory]: typeof defaultFactory;
}
declare const kConnections: unique symbol;
declare const kOptions: unique symbol;
declare const kFactory: unique symbol;
declare function defaultFactory(origin: any, opts: any): Client;
export declare class BalancedPool extends PoolBase {
	constructor(upstreams?: any[], { factory, ...opts }?: {
		factory?: typeof defaultFactory$1;
	});
	addUpstream(upstream: any): this;
	_updateBalancedPoolStats(): void;
	removeUpstream(upstream: any): this;
	get upstreams(): any[];
	[kGetDispatcher](): any;
	[kOptions$1]: {};
	[kIndex]: number;
	[kCurrentWeight]: number;
	[kMaxWeightPerServer]: any;
	[kErrorPenalty]: any;
	[kFactory$1]: typeof defaultFactory$1;
	[kGreatestCommonDivisor]: number;
}
declare const kOptions$1: unique symbol;
declare const kIndex: unique symbol;
declare const kCurrentWeight: unique symbol;
declare const kMaxWeightPerServer: unique symbol;
declare const kErrorPenalty: unique symbol;
declare const kFactory$1: unique symbol;
declare function defaultFactory$1(origin: any, opts: any): Pool;
declare const kGreatestCommonDivisor: unique symbol;
export declare class Agent extends DispatcherBase {
	constructor({ factory, connect, ...options }?: {
		factory?: typeof defaultFactory$2;
	});
	[kOptions$2]: any;
	[kFactory$2]: typeof defaultFactory$2;
	[kOnDrain$1]: (origin: any, targets: any) => void;
	[kOnConnect$1]: (origin: any, targets: any) => void;
	[kOnDisconnect$1]: (origin: any, targets: any, err: any) => void;
	[kOnConnectionError$1]: (origin: any, targets: any, err: any) => void;
}
declare const kOptions$2: unique symbol;
declare const kFactory$2: unique symbol;
declare function defaultFactory$2(origin: any, opts: any): Client | Pool;
declare const kOnDrain$1: unique symbol;
declare const kOnConnect$1: unique symbol;
declare const kOnDisconnect$1: unique symbol;
declare const kOnConnectionError$1: unique symbol;
export declare class ProxyAgent extends DispatcherBase {
	constructor(opts: any);
	[kRequestTls]: any;
	[kProxyTls]: any;
	[kProxyHeaders]: any;
	[kConnectEndpoint]: ({ hostname, host, protocol, port, servername, localAddress, httpSocket }: {
		hostname: any;
		host: any;
		protocol: any;
		port: any;
		servername: any;
		localAddress: any;
		httpSocket: any;
	}, callback: any) => any;
	[kClient]: any;
	[kAgent]: Agent;
	#private;
}
declare const kRequestTls: unique symbol;
declare const kProxyTls: unique symbol;
declare const kProxyHeaders: unique symbol;
declare const kConnectEndpoint: unique symbol;
declare const kClient: unique symbol;
declare const kAgent: unique symbol;
export declare class EnvHttpProxyAgent extends DispatcherBase {
	constructor(opts?: {});
	#private;
}
export declare class RetryAgent extends Dispatcher {
	constructor(agent: any, options?: {});
	dispatch(opts: any, handler: any): any;
	close(): any;
	destroy(): any;
	#private;
}
export declare class RetryHandler {
	constructor(opts: any, handlers: any);
	dispatch: any;
	handler: any;
	opts: any;
	abort: any;
	aborted: boolean;
	retryOpts: {
		retry: any;
		retryAfter: any;
		maxTimeout: any;
		minTimeout: any;
		timeoutFactor: any;
		maxRetries: any;
		methods: any;
		statusCodes: any;
		errorCodes: any;
	};
	retryCount: number;
	retryCountCheckpoint: number;
	start: number;
	end: number;
	etag: string | string[];
	resume: any;
	reason: any;
	onRequestSent(): void;
	onUpgrade(statusCode: any, headers: any, socket: any): void;
	onConnect(abort: any): void;
	onBodySent(chunk: any): any;
	onHeaders(statusCode: any, rawHeaders: any, resume: any, statusMessage: any): any;
	onData(chunk: any): any;
	onComplete(rawTrailers: any): any;
	onError(err: any): any;
}
export declare class DecoratorHandler {
	constructor(handler: any);
	onConnect(...args: any[]): any;
	onError(...args: any[]): any;
	onUpgrade(...args: any[]): any;
	onResponseStarted(...args: any[]): any;
	onHeaders(...args: any[]): any;
	onData(...args: any[]): any;
	onComplete(...args: any[]): any;
	onBodySent(...args: any[]): any;
	#private;
}
export declare class RedirectHandler {
	static buildDispatch(dispatcher: any, maxRedirections: any): (opts: any, originalHandler: any) => any;
	constructor(dispatch: any, maxRedirections: any, opts: any, handler: any);
	dispatch: any;
	location: any;
	abort: any;
	opts: any;
	maxRedirections: any;
	handler: any;
	history: any[];
	redirectionLimitReached: boolean;
	onConnect(abort: any): void;
	onUpgrade(statusCode: any, headers: any, socket: any): void;
	onError(error: any): void;
	onHeaders(statusCode: any, headers: any, resume: any, statusText: any): any;
	onData(chunk: any): any;
	onComplete(trailers: any): void;
	onBodySent(chunk: any): void;
}
export declare function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }: {
	[x: string]: any;
	allowH2: any;
	maxCachedSessions: any;
	socketPath: any;
	timeout: any;
	session: any;
}): ({ hostname, host, protocol, port, servername, localAddress, httpSocket }: {
	hostname: any;
	host: any;
	protocol: any;
	port: any;
	servername: any;
	localAddress: any;
	httpSocket: any;
}, callback: any) => any;
export function setGlobalDispatcher(agent: any): void;
export function getGlobalDispatcher(): any;
export function getGlobalOrigin(): any;
export function setGlobalOrigin(newOrigin: any): void;
declare class Response$1 {
	static error(): Response$1;
	static json(data: any, init?: any, ...args: any[]): Response$1;
	static redirect(url: any, status?: number, ...args: any[]): Response$1;
	constructor(body?: any, init?: any);
	get type(): any;
	get url(): string;
	get redirected(): boolean;
	get status(): any;
	get ok(): boolean;
	get statusText(): any;
	get headers(): any;
	get body(): any;
	get bodyUsed(): boolean;
	clone(): Response$1;
	[nodeUtil.inspect.custom](depth: any, options: any): string;
}
declare class Headers$1 {
	static getHeadersGuard(o: any): any;
	static setHeadersGuard(o: any, guard: any): void;
	static getHeadersList(o: any): any;
	static setHeadersList(o: any, list: any): void;
	constructor(init?: any);
	append(name: any, value: any, ...args: any[]): any;
	delete(name: any, ...args: any[]): void;
	get(name: any, ...args: any[]): string;
	has(name: any, ...args: any[]): boolean;
	set(name: any, value: any, ...args: any[]): void;
	getSetCookie(): [
		string,
		string
	][];
	get [kHeadersSortedMap](): any;
	[util.inspect.custom](depth: any, options: any): string;
	#private;
}
declare const kHeadersSortedMap: unique symbol;
declare class Request$1 {
	constructor(input: any, init?: any, ...args: any[]);
	get method(): any;
	get url(): string;
	get headers(): any;
	get destination(): any;
	get referrer(): any;
	get referrerPolicy(): any;
	get mode(): any;
	get credentials(): any;
	get cache(): any;
	get redirect(): any;
	get integrity(): any;
	get keepalive(): any;
	get isReloadNavigation(): any;
	get isHistoryNavigation(): any;
	get signal(): any;
	get body(): any;
	get bodyUsed(): boolean;
	get duplex(): string;
	clone(): Request$1;
	[nodeUtil.inspect.custom](depth: any, options: any): string;
	[kAbortController]: AbortController;
}
declare const kAbortController: unique symbol;
declare class Cache$1 {
	constructor(...args: any[]);
	match(request: any, options?: {}, ...args: any[]): Promise<Response$1>;
	matchAll(request?: any, options?: {}): Promise<readonly Response$1[]>;
	add(request: any, ...args: any[]): Promise<any>;
	addAll(requests: any, ...args: any[]): Promise<any>;
	put(request: any, response: any, ...args: any[]): Promise<any>;
	delete(request: any, options?: {}, ...args: any[]): Promise<any>;
	/**
	 * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
	 * @param {any} request
	 * @param {import('../../types/cache').CacheQueryOptions} options
	 * @returns {Promise<readonly Request[]>}
	 */
	keys(request?: any, options?: any): Promise<readonly Request$1[]>;
	#private;
}
declare class CacheStorage$1 {
	constructor(...args: any[]);
	match(request: any, options?: {}, ...args: any[]): Promise<Response$1>;
	/**
	 * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
	 * @param {string} cacheName
	 * @returns {Promise<boolean>}
	 */
	has(cacheName: string, ...args: any[]): Promise<boolean>;
	/**
	 * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
	 * @param {string} cacheName
	 * @returns {Promise<Cache>}
	 */
	open(cacheName: string, ...args: any[]): Promise<Cache$1>;
	/**
	 * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
	 * @param {string} cacheName
	 * @returns {Promise<boolean>}
	 */
	delete(cacheName: string, ...args: any[]): Promise<boolean>;
	/**
	 * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
	 * @returns {Promise<string[]>}
	 */
	keys(): Promise<string[]>;
	#private;
}
export type Cookie = {
	name: string;
	value: string;
	expires?: Date | number;
	maxAge?: number;
	domain?: string;
	path?: string;
	secure?: boolean;
	httpOnly?: boolean;
	sameSite?: "Strict" | "Lax" | "None";
	unparsed?: string[];
};
/**
 * @typedef {Object} Cookie
 * @property {string} name
 * @property {string} value
 * @property {Date|number} [expires]
 * @property {number} [maxAge]
 * @property {string} [domain]
 * @property {string} [path]
 * @property {boolean} [secure]
 * @property {boolean} [httpOnly]
 * @property {'Strict'|'Lax'|'None'} [sameSite]
 * @property {string[]} [unparsed]
 */
/**
 * @param {Headers} headers
 * @returns {Record<string, string>}
 */
export function getCookies(headers: Headers$1, ...args: any[]): Record<string, string>;
/**
 * @param {Headers} headers
 * @param {string} name
 * @param {{ path?: string, domain?: string }|undefined} attributes
 * @returns {void}
 */
export function deleteCookie(headers: Headers$1, name: string, attributes: {
	path?: string;
	domain?: string;
} | undefined, ...args: any[]): void;
/**
 * @param {Headers} headers
 * @returns {Cookie[]}
 */
export function getSetCookies(headers: Headers$1, ...args: any[]): Cookie[];
/**
 * @param {Headers} headers
 * @param {Cookie} cookie
 * @returns {void}
 */
export function setCookie(headers: Headers$1, cookie: Cookie, ...args: any[]): void;
/** @param {string} input */
export function parseMIMEType(input: string): "failure" | {
	type: string;
	subtype: string;
	/** @type {Map<string, string>} */
	parameters: Map<string, string>;
	essence: string;
};
/**
 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
 */
export function serializeAMimeType(mimeType: any): any;
/**
 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
 */
declare class MessageEvent$1 extends Event {
	static createFastMessageEvent(type: any, init: any): MessageEvent$1;
	constructor(type: any, eventInitDict?: {}, ...args: any[]);
	get data(): any;
	get origin(): any;
	get lastEventId(): any;
	get source(): any;
	get ports(): any;
	initMessageEvent(type: any, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: any, ports?: any[], ...args: any[]): MessageEvent$1;
	#private;
}
/**
 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
 */
declare class CloseEvent$1 extends Event {
	constructor(type: any, eventInitDict?: {}, ...args: any[]);
	get wasClean(): any;
	get code(): any;
	get reason(): any;
	#private;
}
declare class ErrorEvent$1 extends Event {
	constructor(type: any, eventInitDict: any, ...args: any[]);
	get message(): any;
	get filename(): any;
	get lineno(): any;
	get colno(): any;
	get error(): any;
	#private;
}
declare class MockInterceptor {
	constructor(opts: any, mockDispatches: any);
	createMockScopeDispatchData({ statusCode, data, responseOptions }: {
		statusCode: any;
		data: any;
		responseOptions: any;
	}): {
		statusCode: any;
		data: any;
		headers: any;
		trailers: any;
	};
	validateReplyParameters(replyParameters: any): void;
	/**
	 * Mock an undici request with a defined reply.
	 */
	reply(replyOptionsCallbackOrStatusCode: any, ...args: any[]): MockScope;
	/**
	 * Mock an undici request with a defined error.
	 */
	replyWithError(error: any): MockScope;
	/**
	 * Set default reply headers on the interceptor for subsequent replies
	 */
	defaultReplyHeaders(headers: any): this;
	/**
	 * Set default reply trailers on the interceptor for subsequent replies
	 */
	defaultReplyTrailers(trailers: any): this;
	/**
	 * Set reply content length header for replies on the interceptor
	 */
	replyContentLength(): this;
}
declare class MockScope {
	constructor(mockDispatch: any);
	/**
	 * Delay a reply by a set amount in ms.
	 */
	delay(waitInMs: any): this;
	/**
	 * For a defined reply, never mark as consumed.
	 */
	persist(): this;
	/**
	 * Allow one to define a reply for a set amount of matching requests.
	 */
	times(repeatTimes: any): this;
}
/**
 * MockClient provides an API that extends the Client to influence the mockDispatches.
 */
export declare class MockClient extends Client {
	constructor(origin: any, opts: any);
	dispatch: any;
	close: any;
	/**
	 * Sets up the base interceptor for mocking replies from undici.
	 */
	intercept(opts: any): MockInterceptor;
}
/**
 * MockPool provides an API that extends the Pool to influence the mockDispatches.
 */
export declare class MockPool extends Pool {
	constructor(origin: any, opts: any);
	dispatch: any;
	close: any;
	/**
	 * Sets up the base interceptor for mocking replies from undici.
	 */
	intercept(opts: any): MockInterceptor;
}
declare class PendingInterceptorsFormatter {
	constructor({ disableColors }?: {});
	transform: Transform;
	logger: Console;
	format(pendingInterceptors: any): any;
}
export declare class MockAgent extends Dispatcher {
	get(origin: any): any;
	dispatch(opts: any, handler: any): any;
	close(): Promise<void>;
	deactivate(): void;
	activate(): void;
	enableNetConnect(matcher: any): void;
	disableNetConnect(): void;
	get isMockActive(): any;
	pendingInterceptors(): any[];
	assertNoPendingInterceptors({ pendingInterceptorsFormatter }?: {
		pendingInterceptorsFormatter?: PendingInterceptorsFormatter;
	}): void;
}
type ReadyState$1 = 0 | 1 | 2;
/**
 * The EventSource interface is used to receive server-sent events. It
 * connects to a server over HTTP and receives events in text/event-stream
 * format without closing the connection.
 * @extends {EventTarget}
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events
 * @api public
 */
declare class EventSource$1 extends EventTarget {
	/**
	 * Creates a new EventSource object.
	 * @param {string} url
	 * @param {EventSourceInit} [eventSourceInitDict={}]
	 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
	 */
	constructor(url: string, eventSourceInitDict?: EventSourceInit, ...args: any[]);
	/**
	 * Returns the state of this EventSource object's connection. It can have the
	 * values described below.
	 * @returns {ReadyState}
	 * @readonly
	 */
	readonly get readyState(): ReadyState$1;
	/**
	 * Returns the URL providing the event stream.
	 * @readonly
	 * @returns {string}
	 */
	readonly get url(): string;
	/**
	 * Returns a boolean indicating whether the EventSource object was
	 * instantiated with CORS credentials set (true), or not (false, the default).
	 */
	get withCredentials(): boolean;
	/**
	 * Closes the connection, if any, and sets the readyState attribute to
	 * CLOSED.
	 */
	close(): void;
	set onopen(fn: any);
	get onopen(): any;
	set onmessage(fn: any);
	get onmessage(): any;
	set onerror(fn: any);
	get onerror(): any;
	#private;
}
declare class FormData$1 {
	constructor(form: any);
	append(name: any, value: any, filename?: any, ...args: any[]): void;
	delete(name: any, ...args: any[]): void;
	get(name: any, ...args: any[]): any;
	getAll(name: any, ...args: any[]): any;
	has(name: any, ...args: any[]): boolean;
	set(name: any, value: any, filename?: any, ...args: any[]): void;
	[nodeUtil.inspect.custom](depth: any, options: any): string;
}
declare class WebSocket$1 extends EventTarget {
	/**
	 * @param {string} url
	 * @param {string|string[]} protocols
	 */
	constructor(url: string, protocols?: string | string[], ...args: any[]);
	/**
	 * @see https://websockets.spec.whatwg.org/#dom-websocket-close
	 * @param {number|undefined} code
	 * @param {string|undefined} reason
	 */
	close(code?: number | undefined, reason?: string | undefined): void;
	/**
	 * @see https://websockets.spec.whatwg.org/#dom-websocket-send
	 * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
	 */
	send(data: NodeJS.TypedArray | ArrayBuffer | Blob | string, ...args: any[]): void;
	get readyState(): number;
	get bufferedAmount(): number;
	get url(): string;
	get extensions(): string;
	get protocol(): string;
	set onopen(fn: any);
	get onopen(): any;
	set onerror(fn: any);
	get onerror(): any;
	set onclose(fn: any);
	get onclose(): any;
	set onmessage(fn: any);
	get onmessage(): any;
	set binaryType(type: string);
	get binaryType(): string;
	CONNECTING: number;
	OPEN: number;
	CLOSING: number;
	CLOSED: number;
	#private;
}
declare namespace WebSocket$1 {
	let CONNECTING: number;
	let OPEN: number;
	let CLOSING: number;
	let CLOSED: number;
}
export namespace interceptors {
	let redirect: typeof import("./lib/interceptor/redirect");
	let retry: (globalOpts: any) => (dispatch: any) => (opts: any, handler: any) => any;
	let dump: typeof import("./lib/interceptor/dump");
}
export namespace util {
	let parseHeaders: (headers: (Buffer | string)[], obj?: Record<string, string | string[]>) => Record<string, string | string[]>;
	let headerNameToString: (value: string | Buffer) => string;
}
declare function fetch$1(init: any, options?: any): Promise<any>;
declare const Headers$1: typeof Headers$1;
declare const Response$1: typeof Response$1;
declare const Request$1: typeof Request$1;
declare const FormData$1: typeof FormData$1;
declare const caches$1: CacheStorage$1;
declare const WebSocket$1: typeof WebSocket$1;
export function request(url: any, opts: any, handler: any): any;
export function stream(url: any, opts: any, handler: any): any;
export function pipeline(url: any, opts: any, handler: any): any;
export function connect(url: any, opts: any, handler: any): any;
export function upgrade(url: any, opts: any, handler: any): any;

export {
	CloseEvent$1 as CloseEvent,
	ErrorEvent$1 as ErrorEvent,
	EventSource$1 as EventSource,
	FormData$1 as FormData,
	Headers$1 as Headers,
	MessageEvent$1 as MessageEvent,
	Request$1 as Request,
	Response$1 as Response,
	WebSocket$1 as WebSocket,
	caches$1 as caches,
	fetch$1 as fetch,
};

export {};
